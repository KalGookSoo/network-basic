# 정답 및 해설

이 문서는 각 장의 확인 문제에 대한 정답과 해설을 제공합니다.

## 목차
- [Chapter 01 컴퓨터 네트워크 시작하기](#chapter-01-컴퓨터-네트워크-시작하기)
  - [01-1 컴퓨터 네트워크를 알아야 하는 이유](#01-1-컴퓨터-네트워크를-알아야-하는-이유)
  - [01-2 네트워크 거시적으로 살펴보기](#01-2-네트워크-거시적으로-살펴보기)
  - [01-3 네트워크 미시적으로 살펴보기](#01-3-네트워크-미시적으로-살펴보기)
- [Chapter 02 물리 계층과 데이터 링크 계층](#chapter-02-물리-계층과-데이터-링크-계층)
  - [02-1 이더넷](#02-1-이더넷)
  - [02-2 NIC와 케이블](#02-2-nic와-케이블)
  - [02-3 허브](#02-3-허브)
  - [02-4 스위치](#02-4-스위치)
- [Chapter 03 네트워크 계층](#chapter-03-네트워크-계층)
  - [03-1 LAN을 넘어서는 네트워크 계층](#03-1-lan을-넘어서는-네트워크-계층)
  - [03-2 IP 주소](#03-2-ip-주소)
  - [03-3 라우팅](#03-3-라우팅)
- [Chapter 04 전송 계층](#chapter-04-전송-계층)
  - [04-1 전송 계층 개요: IP의 한계와 포트](#04-1-전송-계층-개요-ip의-한계와-포트)
  - [04-2 TCP와 UDP](#04-2-tcp와-udp)
  - [04-3 TCP의 오류·흐름·혼잡 제어](#04-3-tcp의-오류흐름혼잡-제어)
- [Chapter 05 응용 계층](#chapter-05-응용-계층)
  - [05-1 DNS와 자원](#05-1-dns와-자원)
  - [05-2 HTTP](#05-2-http)
  - [05-3 HTTP 헤더와 HTTP 기반 기술](#05-3-http-헤더와-http-기반-기술)
- [Chapter 06 실습으로 복습하는 네트워크](#chapter-06-실습으로-복습하는-네트워크)
  - [06-1 와이어샤크 설치 및 사용법](#06-1-와이어샤크-설치-및-사용법)
  - [06-2 와이어샤크를 통한 프로토콜 분석](#06-2-와이어샤크를-통한-프로토콜-분석)
- [Chapter 07 네트워크 심화](#chapter-07-네트워크-심화)
  - [07-1 안정성을 위한 기술](#07-1-안정성을-위한-기술)
  - [07-2 안전성을 위한 기술](#07-2-안전성을-위한-기술)
  - [07-3 무선 네트워크](#07-3-무선-네트워크)

## Chapter 01 컴퓨터 네트워크 시작하기

### 01-1 컴퓨터 네트워크를 알아야 하는 이유

#### 문제 1
**문제**: 인터넷을 '네트워크의 네트워크'라고 부르는 이유는 무엇인가요?

**정답**: 수많은 작은 네트워크들이 서로 연결되어 하나의 거대한 네트워크를 형성하기 때문에

**해설**: 인터넷은 전 세계의 수많은 작은 네트워크들이 서로 연결되어 하나의 거대한 네트워크를 형성하고 있습니다. 이러한 구조 때문에 '네트워크의 네트워크'라고 불립니다. 각 네트워크는 독립적으로 운영되지만, 표준화된 프로토콜(TCP/IP)을 통해 서로 통신할 수 있습니다.

#### 문제 2
**문제**: 다음 중 웹 개발자가 프로그램을 만드는 업무에서 네트워크 지식을 활용하는 경우가 아닌 것은?

**정답**: 데이터베이스 스키마 설계

**해설**: 데이터베이스 스키마 설계는 주로 데이터 모델링과 관련된 작업으로, 네트워크 지식보다는 데이터베이스 설계 원칙과 정규화 이론 등의 지식이 더 중요합니다. 반면, API 설계 최적화, 웹 애플리케이션 보안 강화, 네트워크 성능 최적화는 모두 네트워크 지식을 직접적으로 활용하는 업무입니다.

#### 문제 3
**문제**: 웹 개발자에게 네트워크 지식이 중요한 이유를 자신의 경험이나 예시와 함께 설명해보세요.

**모범 답안**: 웹 애플리케이션은 본질적으로 네트워크를 통해 작동하므로, 네트워크의 특성과 제약을 이해하는 것이 효율적이고 안정적인 애플리케이션을 개발하는 데 필수적입니다. 예를 들어, 네트워크 지연 시간을 고려한 비동기 처리, 대역폭 제한을 고려한 자원 최적화, 네트워크 보안 취약점에 대응하는 보안 조치 등이 중요합니다. 실제 개발 환경에서는 API 호출 최적화, 캐싱 전략 수립, CDN 활용, 네트워크 오류 처리 등 다양한 상황에서 네트워크 지식이 필요합니다.

### 01-2 네트워크 거시적으로 살펴보기

#### 문제 1
**문제**: 다음 중 LAN(Local Area Network)의 특징으로 옳지 않은 것은?

**정답**: 넓은 지리적 범위

**해설**: LAN은 제한된 지역 내에서 구성된 네트워크로, 일반적으로 한 건물이나 캠퍼스 내에 구축됩니다. LAN의 특징은 높은 데이터 전송 속도, 낮은 지연 시간, 제한된 지리적 범위, 단일 조직에 의한 소유 및 관리 등입니다. 넓은 지리적 범위는 WAN(Wide Area Network)의 특징입니다.

#### 문제 2
**문제**: 회선 교환 방식과 패킷 교환 방식의 차이점으로 옳은 것은?

**정답**: 회선 교환은 통신 전에 경로를 설정하고, 패킷 교환은 각 패킷이 독립적으로 경로를 찾아간다.

**해설**: 회선 교환 방식은 통신을 시작하기 전에 송신자와 수신자 간에 전용 통신 경로(회선)를 설정하고, 통신이 끝날 때까지 이 경로를 독점적으로 사용합니다. 반면, 패킷 교환 방식은 데이터를 패킷이라는 작은 단위로 나누어 각 패킷이 독립적으로 목적지까지 전송됩니다. 회선 교환은 전통적인 전화망에서 주로 사용되고, 패킷 교환은 인터넷에서 주로 사용됩니다.

#### 문제 3
**문제**: 네트워크에서 유니캐스트, 브로드캐스트, 멀티캐스트의 차이점을 설명하고, 각각의 사용 예시를 들어보세요.

**모범 답안**: 유니캐스트는 하나의 송신자가 하나의 특정 수신자에게 데이터를 전송하는 1:1 통신 방식입니다. 웹 브라우징, 이메일 전송, 파일 다운로드 등에 사용됩니다. 브로드캐스트는 하나의 송신자가 네트워크 내의 모든 호스트에게 데이터를 전송하는 1:모두 통신 방식입니다. ARP 요청, DHCP 요청, 라우팅 정보 업데이트 등에 사용됩니다. 멀티캐스트는 하나의 송신자가 특정 그룹에 속한 다수의 수신자에게 데이터를 전송하는 1:다수 통신 방식입니다. IPTV, 화상 회의, 소프트웨어 업데이트 배포 등에 사용됩니다. 유니캐스트는 특정 수신자만 데이터를 받고, 브로드캐스트는 네트워크 내 모든 호스트가 데이터를 받으며, 멀티캐스트는 특정 그룹에 속한 호스트만 데이터를 받는다는 점에서 차이가 있습니다.

### 01-3 네트워크 미시적으로 살펴보기

#### 문제 1
**문제**: 다음 중 OSI 모델의 7계층을 올바르게 나열한 것은?

**정답**: 물리, 데이터 링크, 네트워크, 전송, 세션, 표현, 응용

**해설**: OSI 모델은 국제표준화기구(ISO)에서 개발한 7계층 모델로, 아래에서 위로 물리 계층, 데이터 링크 계층, 네트워크 계층, 전송 계층, 세션 계층, 표현 계층, 응용 계층 순으로 구성됩니다. 각 계층은 특정 기능을 담당하며, 하위 계층은 상위 계층에 서비스를 제공합니다. 물리 계층은 비트 단위의 데이터 전송을, 데이터 링크 계층은 프레임 단위의 신뢰성 있는 전송을, 네트워크 계층은 패킷 라우팅을, 전송 계층은 종단 간 통신을, 세션 계층은 연결 관리를, 표현 계층은 데이터 형식 변환을, 응용 계층은 사용자 인터페이스와 네트워크 서비스를 제공합니다. TCP/IP 모델은 4계층으로 구성되어 있으며, 네트워크 인터페이스, 인터넷, 전송, 응용 계층으로 구성됩니다.

#### 문제 2
**문제**: 캡슐화 과정에서 데이터에 추가되는 것은?

**정답**: 헤더와 때로는 트레일러가 추가된다

**해설**: 캡슐화(Encapsulation)는 상위 계층에서 하위 계층으로 데이터가 전달될 때 각 계층에서 해당 계층의 제어 정보를 데이터에 추가하는 과정입니다. 이 제어 정보는 주로 헤더 형태로 데이터 앞에 추가되지만, 데이터 링크 계층과 같은 일부 계층에서는 트레일러도 데이터 뒤에 추가됩니다. 예를 들어, 이더넷 프레임은 헤더(목적지 MAC 주소, 출발지 MAC 주소, 타입/길이 필드 등)와 트레일러(FCS, Frame Check Sequence)를 모두 포함합니다. 헤더에는 주소 지정, 오류 검출, 프로토콜 식별 등의 정보가 포함되며, 트레일러에는 주로 오류 검출 코드가 포함됩니다. 역캡슐화 과정에서는 이러한 헤더와 트레일러가 제거되어 원래의 데이터만 상위 계층으로 전달됩니다.

#### 문제 3
**문제**: TCP/IP 모델의 전송 계층에서 사용되는 PDU의 이름은?

**정답**: 세그먼트(TCP) 또는 데이터그램(UDP)

**해설**: PDU(Protocol Data Unit)는 각 계층에서 데이터 단위를 지칭하는 용어입니다. TCP/IP 모델의 전송 계층에서는 프로토콜에 따라 PDU의 이름이 다릅니다. TCP(Transmission Control Protocol)를 사용할 경우 PDU는 '세그먼트(Segment)'라고 부르고, UDP(User Datagram Protocol)를 사용할 경우 '데이터그램(Datagram)'이라고 부릅니다. 세그먼트와 데이터그램은 모두 출발지 포트, 목적지 포트, 체크섬 등의 헤더 정보를 포함하지만, TCP 세그먼트는 신뢰성 있는 전송을 위한 시퀀스 번호, 확인 응답 번호 등의 추가 필드를 포함합니다. 다른 계층의 PDU로는 응용 계층의 데이터/메시지, 인터넷 계층의 패킷, 네트워크 인터페이스 계층의 프레임이 있습니다.

#### 문제 4
**문제**: 네트워크 성능을 측정하는 지표 중, 단위 시간당 실제로 전송되는 데이터의 양을 나타내는 것은?

**정답**: 처리율

**해설**: 처리율(Throughput)은 단위 시간당 실제로 네트워크를 통해 전송되는 데이터의 양을 의미합니다. 일반적으로 비트 단위로 측정되며, bps(bits per second)로 표현됩니다. 처리율은 실제 네트워크 성능을 나타내는 중요한 지표로, 이론적인 최대 전송 속도인 대역폭(Bandwidth)과는 구별됩니다. 대역폭이 네트워크가 처리할 수 있는 최대 데이터 전송 속도를 의미한다면, 처리율은 실제로 전송되는 데이터의 양을 의미합니다. 처리율은 네트워크 혼잡, 프로토콜 오버헤드, 하드웨어 제한 등 다양한 요인에 의해 대역폭보다 낮을 수 있습니다. 지연 시간(Latency)은 데이터가 출발지에서 목적지까지 도달하는 데 걸리는 시간을, 패킷 손실(Packet Loss)은 전송 중 손실되는 패킷의 비율을 나타내는 지표입니다.

#### 문제 5
**문제**: OSI 모델과 TCP/IP 모델의 가장 큰 차이점은?

**정답**: OSI 모델은 7계층, TCP/IP 모델은 4계층으로 구성된다

**해설**: OSI 모델과 TCP/IP 모델의 가장 큰 차이점은 계층의 수와 구성입니다. OSI 모델은 7개의 계층(물리, 데이터 링크, 네트워크, 전송, 세션, 표현, 응용)으로 구성되어 있는 반면, TCP/IP 모델은 4개의 계층(네트워크 인터페이스, 인터넷, 전송, 응용)으로 구성되어 있습니다. TCP/IP 모델의 네트워크 인터페이스 계층은 OSI 모델의 물리 계층과 데이터 링크 계층에 해당하고, 인터넷 계층은 네트워크 계층에, 전송 계층은 전송 계층에, 응용 계층은 세션, 표현, 응용 계층을 포함합니다. OSI 모델은 개념적이고 이론적인 모델로 실제 구현보다는 네트워크 통신을 이해하는 데 도움을 주는 반면, TCP/IP 모델은 실제 인터넷에서 사용되는 프로토콜 스택을 기반으로 합니다. 두 모델 모두 계층적 접근 방식을 통해 네트워크 통신의 복잡성을 관리하고, 각 계층이 독립적으로 발전할 수 있도록 합니다.

## Chapter 02 물리 계층과 데이터 링크 계층

### 02-1 이더넷

#### 문제 1
**문제**: 다음 중 이더넷 프레임의 구성 요소가 아닌 것은?

**정답**: IP 주소

**해설**: 이더넷 프레임은 데이터 링크 계층에서 사용되는 PDU로, 프리앰블, 수신지 MAC 주소, 송신지 MAC 주소, 타입/길이, 데이터, FCS(Frame Check Sequence)로 구성됩니다. IP 주소는 네트워크 계층(OSI 모델의 3계층)에서 사용되는 주소로, 이더넷 프레임 자체에는 포함되지 않습니다. 이더넷 프레임에는 데이터 링크 계층에서 사용하는 MAC 주소만 포함됩니다. IP 주소는 이더넷 프레임의 데이터 부분에 포함된 IP 패킷 내에 존재합니다.

#### 문제 2
**문제**: MAC 주소의 크기는 얼마인가요?

**정답**: 6바이트(48비트)

**해설**: MAC(Media Access Control) 주소는 네트워크 인터페이스 카드(NIC)에 할당된 고유 식별자로, 6바이트(48비트) 크기를 가집니다. MAC 주소는 일반적으로 16진수로 표현되며, 예를 들어 `00:1A:2B:3C:4D:5E`와 같은 형태를 가집니다. 처음 3바이트는 제조사를 식별하는 OUI(Organizationally Unique Identifier)이고, 나머지 3바이트는 제조사가 할당한 고유 번호입니다. MAC 주소는 데이터 링크 계층에서 장치를 식별하는 데 사용되며, 이더넷 프레임의 송신지와 수신지 주소 필드에 포함됩니다.

#### 문제 3
**문제**: 다음 중 이더넷 표준 표기법에서 '1000BASE-T'의 의미로 옳은 것은?

**정답**: 1Gbps 속도를 지원하는 기저대역 방식의 트위스티드 페어 케이블

**해설**: 이더넷 표준 표기법은 `<속도><전송 방식><매체 유형>`의 형식을 따릅니다. '1000BASE-T'에서 '1000'은 1000Mbps, 즉 1Gbps의 데이터 전송 속도를 의미합니다. 'BASE'는 기저대역(Baseband) 방식을 사용한다는 의미로, 디지털 신호를 변조 없이 직접 전송하는 방식입니다. 'T'는 트위스티드 페어(Twisted pair) 케이블을 사용한다는 의미입니다. 따라서 1000BASE-T는 1Gbps 속도로 기저대역 방식을 사용하며 트위스티드 페어 케이블을 통해 데이터를 전송하는 이더넷 표준입니다. 이는 기가비트 이더넷(Gigabit Ethernet)이라고도 불립니다.

#### 문제 4
**문제**: 이더넷과 토큰 링의 가장 큰 차이점은 무엇인가요?

**정답**: 이더넷은 CSMA/CD 방식을 사용하고, 토큰 링은 토큰 기반 접근 제어를 사용한다

**해설**: 이더넷과 토큰 링의 가장 큰 차이점은 매체 접근 제어(MAC) 방식입니다. 이더넷은 CSMA/CD(Carrier Sense Multiple Access with Collision Detection) 방식을 사용합니다. 이 방식에서는 장치가 전송 전에 매체가 사용 중인지 확인하고(Carrier Sense), 사용 중이지 않으면 데이터를 전송합니다. 여러 장치가 동시에 전송을 시도할 경우 충돌이 발생할 수 있으며, 충돌이 감지되면(Collision Detection) 장치들은 무작위 시간 동안 대기한 후 재전송을 시도합니다. 반면, 토큰 링은 토큰 기반 접근 제어 방식을 사용합니다. 특별한 프레임인 '토큰'이 링을 순환하며, 토큰을 가진 장치만 데이터를 전송할 수 있습니다. 이 방식은 충돌이 발생하지 않도록 설계되어 있어, 이더넷의 CSMA/CD와 같은 충돌 감지 메커니즘이 필요하지 않습니다. 또한 토큰 링은 링 토폴로지를 사용하는 반면, 이더넷은 주로 스타 또는 버스 토폴로지를 사용합니다.

## Chapter 04 전송 계층

### 04-3 TCP의 오류·흐름·혼잡 제어

#### 문제 1
**문제**: TCP의 오류 제어 메커니즘 중 하나인 ARQ에 대한 설명으로 옳지 않은 것은?

**정답**: TCP는 항상 Stop-and-Wait ARQ만 사용한다.

**해설**: TCP는 실제로 여러 ARQ 기법을 조합하여 사용합니다. TCP는 기본적으로 슬라이딩 윈도우 기반의 Go-Back-N ARQ와 Selective Repeat ARQ의 특성을 모두 가지고 있습니다. 중복 ACK를 통한 빠른 재전송(Fast Retransmit)과 선택적 확인 응답(SACK, Selective Acknowledgment) 옵션을 통해 손실된 특정 세그먼트만 선택적으로 재전송할 수 있습니다. 따라서 TCP가 항상 Stop-and-Wait ARQ만 사용한다는 설명은 옳지 않습니다.

#### 문제 2
**문제**: TCP의 슬라이딩 윈도우에 대한 설명으로 옳은 것은?

**정답**: 수신자는 TCP 헤더의 윈도우 크기 필드를 통해 처리 가능한 데이터 양을 알린다.

**해설**: TCP의 슬라이딩 윈도우 메커니즘에서 수신자는 TCP 헤더의 윈도우 크기 필드를 통해 자신이 처리할 수 있는 데이터의 양(바이트 수)을 송신자에게 알립니다. 이를 통해 송신자는 수신자의 처리 능력을 초과하지 않는 범위 내에서 데이터를 전송할 수 있습니다. 슬라이딩 윈도우는 흐름 제어와 혼잡 제어 모두에 사용되며, 윈도우 크기는 네트워크 상황과 수신자의 버퍼 상태에 따라 동적으로 조정됩니다. 윈도우 크기가 0이 되면 연결이 종료되는 것이 아니라, 송신자는 데이터 전송을 일시 중지하고 윈도우 프로브를 통해 수신자의 상태를 주기적으로 확인합니다.

#### 문제 3
**문제**: TCP의 혼잡 제어 알고리즘에 대한 설명으로 옳은 것은?

**정답**: 혼잡 회피 단계에서는 혼잡 윈도우가 매 RTT마다 1 MSS씩 증가한다.

**해설**: TCP의 혼잡 제어 알고리즘에서 혼잡 회피(Congestion Avoidance) 단계는 혼잡 윈도우(cwnd)가 임계값(ssthresh)에 도달한 후 시작됩니다. 이 단계에서는 혼잡 윈도우를 선형적으로 증가시키는데, 구체적으로 매 RTT(Round Trip Time)마다 1 MSS(Maximum Segment Size)씩 증가시킵니다. 이는 슬로우 스타트 단계에서의 지수적 증가(매 RTT마다 2배)와 대조됩니다. 빠른 재전송은 타임아웃이 발생하기 전에 중복 ACK(일반적으로 3개)를 감지하면 즉시 수행됩니다. 빠른 회복 단계에서는 혼잡 윈도우를 1 MSS로 재설정하지 않고, 임계값으로 설정하여 혼잡 회피 단계부터 다시 시작합니다.

#### 문제 4
**문제**: ECN(Explicit Congestion Notification)에 대한 설명으로 옳지 않은 것은?

**정답**: ECN은 모든 인터넷 라우터에서 기본적으로 활성화되어 있다.

**해설**: ECN은 모든 인터넷 라우터에서 기본적으로 활성화되어 있지 않습니다. ECN을 사용하기 위해서는 송신자, 수신자, 그리고 경로상의 라우터 모두가 ECN을 지원해야 하며, 많은 네트워크 장비에서는 ECN이 기본적으로 비활성화되어 있거나 아예 지원하지 않는 경우도 있습니다. ECN은 패킷 손실 없이 네트워크 혼잡을 알리는 메커니즘으로, IP 헤더의 특정 필드를 사용하여 혼잡 상태를 표시합니다. ECN을 사용하려면 TCP 연결 수립 시 양쪽 호스트가 ECN을 지원하는지 확인하는 과정이 필요합니다.

#### 문제 5
**문제**: 다음 중 TCP의 흐름 제어와 혼잡 제어의 차이점으로 가장 적절한 것은?

**정답**: 흐름 제어는 수신자의 처리 능력을 고려하고, 혼잡 제어는 네트워크의 혼잡 상태를 고려한다.

**해설**: TCP의 흐름 제어와 혼잡 제어는 목적과 대상이 다릅니다. 흐름 제어는 송신자가 수신자의 처리 능력을 초과하는 속도로 데이터를 전송하는 것을 방지하는 메커니즘으로, 수신자의 버퍼 오버플로우를 방지하는 것이 주요 목적입니다. 반면, 혼잡 제어는 네트워크의 혼잡 상태를 감지하고 대응하여 네트워크 성능을 최적화하는 메커니즘으로, 네트워크 자원의 효율적인 사용과 패킷 손실 방지가 주요 목적입니다. 두 메커니즘 모두 TCP에서 구현되며, UDP에서는 기본적으로 제공되지 않습니다.

#### 문제 6
**문제**: TCP의 재전송 타임아웃(RTO)을 결정하는 요소로 가장 중요한 것은?

**정답**: 왕복 시간(RTT)의 평균과 변동성

**해설**: TCP의 재전송 타임아웃(RTO, Retransmission Timeout)은 주로 왕복 시간(RTT, Round Trip Time)의 평균과 변동성을 기반으로 결정됩니다. TCP는 RTT를 지속적으로 측정하고, 이를 바탕으로 평균 RTT와 RTT의 변동성(편차)을 계산합니다. 이 두 값을 조합하여 적절한 RTO 값을 설정합니다. 일반적으로 RTO는 평균 RTT보다 크게 설정되며, RTT의 변동성이 클수록 RTO도 더 크게 설정됩니다. 이는 네트워크 상황의 변화에 적응하기 위한 것으로, 송신자의 CPU 성능, 수신자의 윈도우 크기, 네트워크 인터페이스 카드의 속도 등은 RTO 결정에 직접적인 영향을 미치지 않습니다.

## Chapter 05 응용 계층

### 05-1 DNS와 자원

#### 문제 1
**문제**: DNS의 주요 기능은 무엇인가요?

**정답**: 도메인 이름을 IP 주소로 변환하는 것

**해설**: DNS(Domain Name System)는 사람이 이해하기 쉬운 도메인 이름(예: www.example.com)을 컴퓨터가 이해할 수 있는 IP 주소(예: 93.184.216.34)로 변환해주는 시스템입니다. 이는 인터넷의 '전화번호부' 역할을 하며, 사용자가 웹사이트에 접속하거나 이메일을 보내는 등의 인터넷 활동을 할 때 필수적인 기능입니다. DNS가 없다면 사용자는 모든 웹사이트의 IP 주소를 기억해야 하는 불편함이 있을 것입니다.

#### 문제 2
**문제**: 다음 중 DNS 계층 구조에 포함되지 않는 것은?

**정답**: 프록시 네임 서버

**해설**: DNS 계층 구조는 루트 네임 서버, TLD(최상위 도메인) 네임 서버, 권한 있는 네임 서버, 로컬 DNS 서버로 구성됩니다. 프록시 네임 서버는 DNS 계층 구조의 일부가 아니라, 웹 프록시 서버의 한 종류로 웹 트래픽을 중개하는 역할을 합니다. 루트 네임 서버는 DNS 계층의 최상위에 위치하며, TLD 네임 서버는 .com, .org 등의 최상위 도메인을 관리합니다. 권한 있는 네임 서버는 특정 도메인의 DNS 레코드를 관리하고, 로컬 DNS 서버는 사용자의 DNS 쿼리를 처리하는 첫 번째 서버입니다.

#### 문제 3
**문제**: URL의 구성 요소가 아닌 것은?

**정답**: 메타데이터(metadata)

**해설**: URL(Uniform Resource Locator)의 구성 요소는 스킴(scheme), 권한(authority), 경로(path), 쿼리(query), 프래그먼트(fragment)입니다. 메타데이터는 URL의 구성 요소가 아닙니다. 스킴은 사용할 프로토콜(http, https 등)을 지정하고, 권한은 호스트 이름과 포트 번호를 포함합니다. 경로는 서버 내 자원의 위치를, 쿼리는 자원에 전달할 매개변수를, 프래그먼트는 자원 내의 특정 부분을 가리키는 식별자입니다. 메타데이터는 데이터에 대한 데이터로, URL 자체가 아닌 자원에 대한 추가 정보를 의미합니다.

#### 문제 4
**문제**: example.com의 IP 주소를 찾기 위한 DNS 조회 과정의 올바른 순서는?

**정답**: 로컬 DNS 서버 → 루트 네임 서버 → TLD 네임 서버 → 권한 있는 네임 서버

**해설**: DNS 조회 과정은 일반적으로 다음 순서로 진행됩니다: 1) 사용자의 컴퓨터는 로컬 DNS 서버(보통 ISP가 제공)에 쿼리를 보냅니다. 2) 로컬 DNS 서버는 루트 네임 서버에 쿼리를 보내 TLD 서버 정보를 얻습니다. 3) 로컬 DNS 서버는 TLD 네임 서버(예: .com 서버)에 쿼리를 보내 권한 있는 네임 서버 정보를 얻습니다. 4) 로컬 DNS 서버는 권한 있는 네임 서버에 쿼리를 보내 최종적으로 도메인의 IP 주소를 얻습니다. 이 과정은 재귀적 쿼리 또는 반복적 쿼리 방식으로 수행될 수 있으며, 캐싱을 통해 효율성을 높일 수 있습니다.

#### 문제 5
**문제**: 다음 중 이메일 서버를 지정하는 DNS 레코드 타입은?

**정답**: MX 레코드

**해설**: MX(Mail Exchange) 레코드는 도메인의 이메일 서버를 지정하는 DNS 레코드 타입입니다. 이메일을 보낼 때, 메일 서버는 수신자 도메인의 MX 레코드를 조회하여 어떤 서버로 이메일을 전달해야 하는지 결정합니다. A 레코드는 도메인 이름을 IPv4 주소에 매핑하고, CNAME 레코드는 도메인의 별칭을 설정하며, TXT 레코드는 도메인에 대한 텍스트 정보를 저장합니다. 각 MX 레코드에는 우선순위 값이 있어, 여러 메일 서버가 있을 경우 어떤 서버를 먼저 시도할지 결정합니다.

#### 문제 6
**문제**: URI와 URL의 관계를 올바르게 설명한 것은?

**정답**: URL은 URI의 한 종류이다

**해설**: URI(Uniform Resource Identifier)는 인터넷 상의 자원을 식별하는 문자열의 일반적인 형식입니다. URL(Uniform Resource Locator)은 URI의 한 종류로, 자원의 위치를 지정하는 방식입니다. 모든 URL은 URI이지만, 모든 URI가 URL인 것은 아닙니다. URI의 또 다른 종류로는 URN(Uniform Resource Name)이 있으며, 이는 자원의 이름을 통해 자원을 식별합니다. 예를 들어, "https://www.example.com"은 URL이면서 URI이고, "urn:isbn:0451450523"은 URL이 아닌 URI(URN)입니다.

#### 문제 7
**문제**: DNS 캐싱의 주요 목적은 무엇인가요?

**정답**: DNS 조회 성능을 향상시키기 위해

**해설**: DNS 캐싱의 주요 목적은 DNS 조회 성능을 향상시키는 것입니다. DNS 조회 과정은 여러 단계를 거쳐야 하므로 시간이 소요됩니다. 한 번 조회한 도메인 이름과 IP 주소의 매핑 정보를 캐시에 저장해두면, 동일한 도메인에 대한 후속 요청 시 전체 DNS 조회 과정을 반복할 필요 없이 캐시에서 바로 정보를 제공할 수 있습니다. 이는 응답 시간을 크게 단축시키고, 네트워크 트래픽을 줄이며, DNS 서버의 부하를 감소시킵니다. 캐시된 정보는 TTL(Time To Live) 값에 따라 일정 시간 동안만 유효하며, 이후에는 새로운 조회가 필요합니다.

### 05-2 HTTP

#### 문제 1
**문제**: HTTP의 특성으로 옳지 않은 것은?

**정답**: 상태 유지(stateful) 프로토콜이다

**해설**: HTTP는 기본적으로 스테이트리스(stateless) 프로토콜입니다. 즉, 각 요청은 독립적이며 이전 요청과의 관계를 유지하지 않습니다. 서버는 클라이언트의 상태를 저장하지 않으며, 각 요청을 완전히 새로운 요청으로 처리합니다. 이러한 특성은 서버의 확장성을 높이지만, 사용자 세션과 같은 상태 정보가 필요한 웹 애플리케이션에서는 제약이 될 수 있습니다. 이 제약을 극복하기 위해 쿠키, 세션, 토큰 등의 메커니즘이 도입되었습니다.

#### 문제 2
**문제**: 다음 중 HTTP 메서드와 그 용도가 올바르게 짝지어진 것은?

**정답**: POST - 서버에 데이터를 제출하여 처리 요청

**해설**: POST 메서드는 서버에 데이터를 제출하여 새 리소스를 생성하거나 기존 리소스를 수정하는 등의 처리를 요청하는 데 사용됩니다. GET은 리소스의 표현을 요청하는 메서드로, 서버의 상태를 변경해서는 안 됩니다. PUT은 지정된 리소스를 요청 본문의 내용으로 완전히 대체하는 메서드이며, PATCH는 리소스의 일부만 수정하는 메서드입니다. DELETE는 지정된 리소스를 삭제하는 메서드입니다.

#### 문제 3
**문제**: HTTP 상태 코드 401과 403의 차이점으로 옳은 것은?

**정답**: 401은 인증 실패, 403은 권한 부족을 의미한다

**해설**: 401 Unauthorized는 인증이 필요한 리소스에 인증 없이 접근했거나 인증이 실패했음을 의미합니다. 클라이언트는 적절한 인증 정보를 제공해야 합니다. 403 Forbidden은 서버가 요청을 이해했지만 권한이 없어 거부했음을 의미합니다. 즉, 클라이언트가 누구인지 서버가 알고 있지만, 해당 리소스에 접근할 권한이 없는 경우입니다. 401은 "당신이 누구인지 모르니 인증해주세요"라는 의미이고, 403은 "당신이 누구인지 알지만 이 리소스에 접근할 권한이 없습니다"라는 의미입니다.

#### 문제 4
**문제**: HTTP/2의 주요 특징이 아닌 것은?

**정답**: UDP 기반 전송 프로토콜

**해설**: HTTP/2는 TCP를 기반으로 하는 프로토콜입니다. UDP 기반 전송 프로토콜은 HTTP/3의 특징으로, HTTP/3는 QUIC(Quick UDP Internet Connections)이라는 UDP 기반 프로토콜을 사용합니다. HTTP/2의 주요 특징으로는 바이너리 프로토콜, 멀티플렉싱(하나의 연결로 여러 요청과 응답을 동시에 처리), 헤더 압축, 서버 푸시, 스트림 우선순위 지정 등이 있습니다.

#### 문제 5
**문제**: HTTP 메시지의 구성 요소를 올바른 순서로 나열한 것은?

**정답**: 시작 라인(또는 상태 라인) → 헤더 → 빈 줄 → 본문

**해설**: HTTP 메시지는 요청 메시지와 응답 메시지로 구분되며, 둘 다 동일한 구조를 따릅니다. 요청 메시지는 시작 라인(메서드, URI, HTTP 버전), 헤더, 빈 줄, 본문 순으로 구성됩니다. 응답 메시지는 상태 라인(HTTP 버전, 상태 코드, 상태 메시지), 헤더, 빈 줄, 본문 순으로 구성됩니다. 빈 줄은 헤더와 본문을 구분하는 역할을 하며, 헤더가 끝나고 본문이 시작됨을 나타냅니다.

#### 문제 6
**문제**: 다음 중 멱등성(idempotent)을 가진 HTTP 메서드는?

**정답**: GET

**해설**: 멱등성(idempotent)이란 동일한 요청을 여러 번 수행해도 결과가 같은 성질을 말합니다. GET, HEAD, PUT, DELETE 메서드는 멱등성을 가집니다. GET은 리소스를 조회하는 메서드로, 여러 번 요청해도 동일한 결과를 반환합니다. POST는 일반적으로 멱등성을 가지지 않습니다. 예를 들어, 동일한 POST 요청을 여러 번 보내면 여러 개의 리소스가 생성될 수 있습니다. PATCH도 일반적으로 멱등성을 보장하지 않지만, 구현에 따라 멱등성을 가질 수도 있습니다.

### 05-3 HTTP 헤더와 HTTP 기반 기술

#### 문제 1
**문제**: 다음 중 요청 헤더가 아닌 것은?

**정답**: Set-Cookie

**해설**: Set-Cookie는 요청 헤더가 아닌 응답 헤더입니다. 서버가 클라이언트에게 쿠키를 설정하도록 지시할 때 사용됩니다. 반면, Host, User-Agent, Referer는 모두 요청 헤더입니다. Host는 요청하는 호스트와 포트 번호를 지정하는 헤더로 HTTP/1.1에서는 필수 헤더입니다. User-Agent는 클라이언트 애플리케이션의 정보를 제공하는 헤더이고, Referer는 현재 요청된 페이지의 이전 웹 페이지 주소를 지정하는 헤더입니다.

#### 문제 2
**문제**: Cache-Control 헤더의 지시어 중 캐시된 응답을 사용하기 전에 서버에 검증 요청을 보내야 함을 의미하는 것은?

**정답**: no-cache

**해설**: Cache-Control 헤더의 no-cache 지시어는 캐시된 응답을 사용하기 전에 서버에 검증 요청을 보내야 함을 의미합니다. 이는 캐시를 사용하지 말라는 의미가 아니라, 캐시된 응답을 사용하기 전에 서버에 해당 응답이 여전히 유효한지 확인해야 한다는 의미입니다. 반면, no-store는 어떤 캐시도 응답을 저장하지 않도록 지시하고, private은 브라우저와 같은 특정 사용자 캐시만 응답을 저장할 수 있도록 하며, public은 모든 캐시가 응답을 저장할 수 있도록 지시합니다.

#### 문제 3
**문제**: 쿠키의 SameSite 속성에 대한 설명으로 옳지 않은 것은?

**정답**: None: 모든 크로스 사이트 요청에 쿠키를 전송(Secure 속성 없이도 사용 가능)

**해설**: SameSite=None 설정은 모든 크로스 사이트 요청에 쿠키를 전송할 수 있게 하지만, 반드시 Secure 속성과 함께 사용해야 합니다. 즉, SameSite=None; Secure 형태로 설정해야 하며, Secure 속성 없이는 사용할 수 없습니다. 이는 보안상의 이유로, HTTPS 연결에서만 쿠키가 전송되도록 하기 위함입니다. SameSite=Strict는 같은 사이트의 요청에만 쿠키를 전송하고, SameSite=Lax는 같은 사이트와 일부 크로스 사이트 요청(주로 탑 레벨 네비게이션)에 쿠키를 전송합니다. 브라우저마다 SameSite의 기본값은 다를 수 있으며, 최근 많은 브라우저에서는 기본값을 Lax로 설정하고 있습니다.

#### 문제 4
**문제**: 다음 Accept-Language 헤더에서 가장 선호하는 언어는?
```
Accept-Language: fr-CH, fr;q=0.9, en;q=0.8, de;q=0.7, *;q=0.5
```

**정답**: fr-CH

**해설**: Accept-Language 헤더에서 품질 값(q)이 명시되지 않은 언어의 기본 q 값은 1입니다. 따라서 fr-CH의 q 값은 1로, 이는 fr(q=0.9), en(q=0.8), de(q=0.7), *(q=0.5)보다 높습니다. 즉, 이 헤더는 스위스 프랑스어(fr-CH)를 가장 선호하고, 그 다음으로 프랑스어(fr), 영어(en), 독일어(de) 순으로 선호함을 나타냅니다. 별표(*)는 모든 언어를 의미하며, 명시된 언어가 없을 경우 어떤 언어든 수용할 수 있음을 나타냅니다.

#### 문제 5
**문제**: 다음 중 ETag 헤더의 주요 용도로 가장 적절한 것은?

**정답**: 리소스의 특정 버전을 식별하여 캐시 검증에 사용

**해설**: ETag(Entity Tag) 헤더는 리소스의 특정 버전에 대한 식별자로, 리소스가 변경되면 ETag 값도 변경됩니다. 이는 주로 캐시 검증에 사용됩니다. 클라이언트는 이전에 받은 ETag 값을 If-None-Match 헤더에 포함시켜 서버에 요청을 보내고, 서버는 현재 리소스의 ETag와 비교하여 리소스가 변경되었는지 확인합니다. 리소스가 변경되지 않았다면 서버는 304 Not Modified 응답을 보내 클라이언트가 캐시된 응답을 사용하도록 합니다. 이를 통해 불필요한 데이터 전송을 줄이고 네트워크 효율성을 높일 수 있습니다.

[이하 각 장의 문제와 정답 형식은 위와 동일하게 구성됩니다.]
